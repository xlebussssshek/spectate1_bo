import asyncio
from datetime import datetime, timedelta
import os
from dotenv import load_dotenv
from telethon import TelegramClient, events
from telethon.tl.types import UserStatusOnline, UserStatusOffline, UpdateUserTyping, UpdateReadHistoryOutbox
from aiogram import Bot, Dispatcher, types
from aiogram.enums import ParseMode
from aiogram.client.default import DefaultBotProperties
from aiogram.filters import Command
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton, InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.utils.keyboard import InlineKeyboardBuilder

load_dotenv()

# ================== НАСТРОЙКИ ==================
API_ID = int(os.getenv("API_ID"))
API_HASH = os.getenv("API_HASH")
BOT_TOKEN = os.getenv("BOT_TOKEN")
ADMIN_CHAT_ID = int(os.getenv("ADMIN_ID"))

TARGETS = [
    os.getenv("TARGET1"),
    os.getenv("TARGET2"),
    os.getenv("TARGET3"),
    os.getenv("TARGET4")
]

SESSION_NAME = "monitor_session"

# ================== КЛИЕНТЫ ==================
client = TelegramClient(SESSION_NAME, API_ID, API_HASH)
bot = Bot(token=BOT_TOKEN, default=DefaultBotProperties(parse_mode=ParseMode.HTML))
dp = Dispatcher()

tracked_users = {}
user_names = {}          
user_notifications = {}       
notifications_enabled = True  
last_typing = {}         
last_read = {}           
last_message_sent = {}   

TYPING_COOLDOWN = 30
READ_COOLDOWN = 5


def now():
    return datetime.now().strftime("%H:%M:%S")

def get_main_keyboard():
    """Главная клавиатура"""
    keyboard = ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text="Управление уведомлениями")],
            [KeyboardButton(text="Общий статус")]
        ],
        resize_keyboard=True
    )
    return keyboard

def get_users_inline_keyboard():
    """Инлайн клавиатура со списком людей"""
    builder = InlineKeyboardBuilder()
    
    for user_id, name in user_names.items():
        status = "(вкл)" if user_notifications.get(user_id, True) else "(выкл)"
        builder.button(
            text=f"{status} {name}",
            callback_data=f"toggle_{user_id}"
        )
    
    builder.button(text="Назад", callback_data="back_to_main")
    builder.adjust(1)
    return builder.as_markup()

async def notify(text: str):
    """Отправка уведомления только если включено"""
    if notifications_enabled:
        try:
            await bot.send_message(ADMIN_CHAT_ID, text)
        except Exception as e:
            print(f"Ошибка отправки: {e}")

# ================== КОМАНДЫ БОТА ==================
@dp.message(Command("start"))
async def cmd_start(message: types.Message):
    
    text = "Бот мониторинга\n\n"
    
    for user_id, name in user_names.items():
        status = "(вкл)" if user_notifications.get(user_id, True) else "(выкл)"
        text += f"- {status} {name}\n"
    
    text += "\nУправление через кнопки"
    
    await message.answer(text, reply_markup=get_main_keyboard())

@dp.message(lambda message: message.text == "Управление уведомлениями")
async def manage_notifications(message: types.Message):
    if not user_names:
        await message.answer("Список людей пуст")
        return
    
    await message.answer(
        "Управление уведомлениями\n\n"
        "Нажми на человека чтобы включить/выключить:",
        reply_markup=get_users_inline_keyboard()
    )

@dp.message(lambda message: message.text == "Общий статус")
async def show_status(message: types.Message):
    text = "Общий статус\n\n"
    
    for user_id, name in user_names.items():
        status = "вкл" if user_notifications.get(user_id, True) else "выкл"
        text += f"- {name}: {status}\n"
    
    await message.answer(text, reply_markup=get_main_keyboard())

@dp.callback_query(lambda c: c.data.startswith("toggle_"))
async def toggle_user(callback: types.CallbackQuery):
    user_id = int(callback.data.replace("toggle_", ""))
    
    
    current = user_notifications.get(user_id, True)
    user_notifications[user_id] = not current
    
    name = user_names.get(user_id, "Неизвестно")
    status = "включены" if user_notifications[user_id] else "выключены"
    
    await callback.answer(f"Уведомления для {name} {status}")
    

    await callback.message.edit_reply_markup(reply_markup=get_users_inline_keyboard())

@dp.callback_query(lambda c: c.data == "back_to_main")
async def back_to_main(callback: types.CallbackQuery):
    await callback.message.delete()
    await callback.message.answer("Главное меню:", reply_markup=get_main_keyboard())

# ================== ЗАГРУЗКА ЦЕЛЕЙ ==================
async def setup_tracking():
    await client.start()
    me = await client.get_me()
    print(f"Монитор-аккаунт: {me.first_name} (ID: {me.id})")

    for target in TARGETS:
        if not target:
            continue
        try:
            entity = await client.get_entity(target)
            name = entity.first_name if hasattr(entity, 'first_name') else entity.title
            tracked_users[entity.id] = entity
            user_names[entity.id] = name
            user_notifications[entity.id] = True 
            last_typing[entity.id] = datetime.min
            last_read[entity.id] = datetime.min
            print(f"Отслеживается: {name}")
        except Exception as e:
            print(f"Ошибка загрузки {target}: {e}")

# ================== ОТПРАВЛЕННЫЕ СООБЩЕНИЯ ==================
@client.on(events.NewMessage(outgoing=True))
async def outgoing_message_handler(event):
    """Запоминаем последнее отправленное сообщение цели"""
    message = event.message
    if message.peer_id and hasattr(message.peer_id, 'user_id'):
        user_id = message.peer_id.user_id
        if user_id in tracked_users:
            last_message_sent[user_id] = message.id
            print(f"Сообщение отправлено {tracked_users[user_id].first_name}")

# ================== ПРОЧТЕНИЕ СООБЩЕНИЙ ==================
@client.on(events.Raw)
async def read_handler(event):
    """Когда наши сообщения прочитаны"""
    if isinstance(event, UpdateReadHistoryOutbox):
        user_id = event.peer.user_id if hasattr(event.peer, 'user_id') else None
        
        if user_id in tracked_users and last_message_sent.get(user_id):
            if event.max_id and event.max_id >= last_message_sent[user_id]:
                last = last_read[user_id]
                if (datetime.now() - last).total_seconds() >= READ_COOLDOWN:
                    last_read[user_id] = datetime.now()
                    name = tracked_users[user_id].first_name
                    await notify(f"{name} прочитал сообщение\n{now()}")

# ================== ONLINE/OFFLINE ==================
@client.on(events.UserUpdate)
async def status_handler(event):
    """Изменение статуса онлайн/оффлайн"""
    if event.user_id in tracked_users:
        name = tracked_users[event.user_id].first_name

        if isinstance(event.status, UserStatusOnline):
            await notify(f"{name} зашел в сеть\n{now()}")

        elif isinstance(event.status, UserStatusOffline):
            await notify(f"{name} вышел из сети\n{now()}")

# ================== ПЕЧАТАЕТ ==================
@client.on(events.Raw)
async def typing_handler(event):
    """Когда пользователь печатает"""
    if isinstance(event, UpdateUserTyping):
        user_id = event.user_id
        if user_id in tracked_users:
            last = last_typing[user_id]
            if (datetime.now() - last).total_seconds() >= TYPING_COOLDOWN:
                last_typing[user_id] = datetime.now()
                name = tracked_users[user_id].first_name
                await notify(f"{name} печатает...\n{now()}")

# ================== MAIN ==================
async def main():
    await setup_tracking()
    print("\nМониторинг запущен")
    print("Отслеживается: онлайн, печатает, прочтение сообщений")
    print("Управление через кнопки в боте\n")
    
    
    await bot.send_message(
        ADMIN_CHAT_ID, 
        "<b>Мониторинг запущен!</b>\n\nИспользуй кнопки для управления:",
        reply_markup=get_main_keyboard()
    )
    
    await asyncio.gather(
        client.run_until_disconnected(),
        dp.start_polling(bot)
    )

if __name__ == "__main__":
    asyncio.run(main())